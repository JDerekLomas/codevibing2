<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Reframing Relationships — codevibing session</title>
<meta property="og:title" content="Reframing Relationships — A Therapy Card Deck">
<meta property="og:description" content="Watch a 63-card therapy deck get built with AI across 2 sessions">
<meta name="twitter:card" content="summary_large_image">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #08080c; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; font-family: -apple-system, sans-serif; color: white; }
  canvas { border-radius: 12px; max-width: 100%; height: auto; cursor: pointer; }
  .back { position: fixed; top: 20px; left: 20px; color: #6a6a80; text-decoration: none; font-size: 14px; z-index: 10; }
  .back:hover { color: #f0ece4; }
</style>
</head>
<body>

<a href="/sessions" class="back">&larr; all sessions</a>
<canvas id="canvas" width="1280" height="720"></canvas>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const W = 1280, H = 720;

const C = {
  bg: '#08080c',
  surface: '#101018',
  border: '#1c1c2c',
  text: '#f0ece4',
  dim: '#7a7068',
  prompt: '#6ee7b7',
  ai: '#93c5fd',
  code: '#fbbf24',
  accent: '#c67b5c',
  violet: '#a78bfa',
  rust: '#c67b5c',
  lapis: '#4a7bbd',
  gold: '#C4A35A',
};

const images = {};
const imageSources = {
  anti: '/therapycards/anti-01.png',
  domain: '/therapycards/domain-01.png',
  horseman: '/therapycards/horseman-01.png',
  mode: '/therapycards/mode-01.png',
  need: '/therapycards/need-01.png',
  pattern: '/therapycards/pattern-01.png',
};

let imagesLoaded = 0;
Object.entries(imageSources).forEach(([key, src]) => {
  const img = new Image();
  img.onload = () => { imagesLoaded++; };
  img.onerror = () => { imagesLoaded++; };
  img.src = src;
  images[key] = img;
});

const events = [
  { t: 0, type: 'title-card', bgImage: 'pattern', title: 'Reframing Relationships', subtitle: 'A Therapy Card Deck', meta: 'built with Claude Code \u00b7 Jan 2026' },

  { t: 5000, type: 'terminal-start' },
  { t: 5500, type: 'prompt', text: "I want to make a new carddeck for marriage and family therapy" },
  { t: 8500, type: 'prompt', text: "I like decks where you pull cards out in a spread. Maybe a two player game" },
  { t: 11500, type: 'ai', text: "Researching Gottman Method, EFT, Bowen Family Systems..." },

  { t: 14000, type: 'prompt', text: "yes, make it using the templates we have for the alchemy cards" },
  { t: 17000, type: 'prompt', text: "yes, with mulerouter" },
  { t: 19500, type: 'ai', text: "Generating watercolor artwork for 63 cards..." },

  { t: 22000, type: 'image-reveal', key: 'horseman', label: 'Four Horsemen \u00b7 Gottman Method' },

  { t: 28000, type: 'terminal-resume' },
  { t: 28500, type: 'prompt', text: "more antidotes or tactics. Font is kind of small in the warning signs" },
  { t: 31500, type: 'prompt', text: "add more examples to help people think" },
  { t: 34500, type: 'prompt', text: "the formatting needs to be exactly the same as the alchemy cards" },

  { t: 37000, type: 'image-reveal', key: 'need', label: 'Core Needs \u00b7 Desmet Framework' },

  { t: 43000, type: 'terminal-resume' },
  { t: 43500, type: 'prompt', text: "display these online with rules for play" },
  { t: 46500, type: 'prompt', text: "show example spreads with cards in the how to play" },
  { t: 49500, type: 'code', text: "Reframing Relationships \u2014 63 cards, 6 categories" },

  { t: 52000, type: 'image-grid', keys: ['anti', 'domain', 'horseman', 'mode'] },

  { t: 60500, type: 'terminal-resume' },
  { t: 61000, type: 'prompt', text: "make the print cards. I want to print them on makeplayingcards" },
  { t: 64000, type: 'prompt', text: "The concept and title is 'Reframing Relationships'" },
  { t: 67000, type: 'prompt', text: "Category specific backs. Reframing Relationships big and central" },
  { t: 70000, type: 'ai', text: "Print-ready cards rendered at 300 DPI" },

  { t: 72500, type: 'prompt', text: "Document how we did this into a card deck creation skill" },
  { t: 75500, type: 'ai', text: "Card deck creation skill saved" },

  { t: 78000, type: 'image-grid', keys: ['pattern', 'need', 'anti', 'mode'] },

  { t: 86500, type: 'title-card', bgImage: 'need', title: 'Reframing Relationships', subtitle: 'designtherapy.vercel.app/resources', meta: '63 therapy cards \u00b7 built with Claude Code' },

  { t: 92500, type: 'end' },
];

let startTime = null;
let animFrame = null;
let currentElapsed = 0;
let animRunning = false;
let zoom = 1, zoomTarget = 1, panY = 0, panYTarget = 0;

function lerp(a, b, t) { return a + (b - a) * Math.min(Math.max(t, 0), 1); }
function easeOut(t) { return 1 - Math.pow(1 - Math.min(t, 1), 3); }

function drawRoundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y); ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r); ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h); ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r); ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y); ctx.closePath();
}

function drawImageCover(img, x, y, w, h) {
  if (!img || !img.complete || !img.naturalWidth) return;
  const imgR = img.naturalWidth / img.naturalHeight, boxR = w / h;
  let sx = 0, sy = 0, sw = img.naturalWidth, sh = img.naturalHeight;
  if (imgR > boxR) { sw = sh * boxR; sx = (img.naturalWidth - sw) / 2; }
  else { sh = sw / boxR; sy = (img.naturalHeight - sh) / 2; }
  ctx.drawImage(img, sx, sy, sw, sh, x, y, w, h);
}

function getActiveMode(elapsed) {
  const visible = events.filter(e => e.t <= elapsed);
  for (let i = visible.length - 1; i >= 0; i--) {
    const t = visible[i].type;
    if (t === 'title-card') return 'title-card';
    if (t === 'image-reveal') return 'image-reveal';
    if (t === 'image-grid') return 'image-grid';
    if (t === 'terminal-resume' || t === 'terminal-start') return 'terminal';
    if (['prompt','ai','code'].includes(t)) return 'terminal';
  }
  return 'title-card';
}

function drawTitleCard(elapsed) {
  const cards = events.filter(e => e.t <= elapsed && e.type === 'title-card');
  const card = cards[cards.length - 1];
  if (!card) return;
  const age = elapsed - card.t;
  const img = images[card.bgImage];

  if (img && img.complete && img.naturalWidth) {
    ctx.globalAlpha = easeOut(Math.min(age / 1200, 1));
    drawImageCover(img, 0, 0, W, H);
    const ov = ctx.createLinearGradient(0, 0, 0, H);
    ov.addColorStop(0, 'rgba(8,8,12,0.4)');
    ov.addColorStop(0.4, 'rgba(8,8,12,0.3)');
    ov.addColorStop(0.7, 'rgba(8,8,12,0.6)');
    ov.addColorStop(1, 'rgba(8,8,12,0.85)');
    ctx.fillStyle = ov; ctx.fillRect(0, 0, W, H);
    ctx.globalAlpha = 1;
  }

  ctx.globalAlpha = Math.max(easeOut(Math.min((age - 500) / 800, 1)), 0);
  const tx = 80, ty = H - 120;
  ctx.shadowColor = 'rgba(0,0,0,0.7)'; ctx.shadowBlur = 24;
  ctx.font = '700 72px -apple-system, sans-serif';
  ctx.fillStyle = '#fff'; ctx.textAlign = 'left';
  ctx.fillText(card.title, tx, ty);
  ctx.font = '300 28px -apple-system, sans-serif';
  ctx.fillStyle = C.gold; ctx.shadowBlur = 12;
  ctx.fillText(card.subtitle, tx, ty + 42);
  if (card.meta) {
    ctx.font = '400 15px -apple-system, sans-serif';
    ctx.fillStyle = 'rgba(255,255,255,0.5)'; ctx.shadowBlur = 6;
    ctx.fillText(card.meta, tx, ty + 72);
  }
  ctx.shadowBlur = 0; ctx.globalAlpha = 1;
}

function drawTerminal(elapsed) {
  zoom = lerp(zoom, zoomTarget, 0.06);
  panY = lerp(panY, panYTarget, 0.06);
  ctx.save();
  ctx.translate(W/2, H/2); ctx.scale(zoom, zoom); ctx.translate(-W/2, -H/2 + panY);

  const tX = 60, tY = 30, tW = W - 120, tH = H - 60;
  drawRoundRect(tX, tY, tW, tH, 14); ctx.fillStyle = C.surface; ctx.fill();
  ctx.strokeStyle = C.border; ctx.lineWidth = 1; ctx.stroke();

  drawRoundRect(tX, tY, tW, 44, 14); ctx.fillStyle = '#141420'; ctx.fill();
  ctx.fillStyle = C.surface; ctx.fillRect(tX + 1, tY + 30, tW - 2, 14);

  const dY = tY + 22;
  [[tX+22,'#ff5f57'],[tX+42,'#ffbd2e'],[tX+62,'#28c840']].forEach(([dx,c]) => {
    ctx.beginPath(); ctx.arc(dx, dY, 6, 0, Math.PI*2);
    ctx.fillStyle = c; ctx.globalAlpha = 0.85; ctx.fill(); ctx.globalAlpha = 1;
  });
  ctx.font = '500 13px "SF Mono", monospace'; ctx.fillStyle = C.dim;
  ctx.fillText('~/CardDecks/mft-deck \u00b7 claude', tX + 86, dY + 4);
  const secs = Math.floor(elapsed / 1000);
  ctx.textAlign = 'right'; ctx.font = '12px "SF Mono", monospace';
  ctx.fillText(`${Math.floor(secs/60)}:${String(secs%60).padStart(2,'0')}`, tX + tW - 18, dY + 4);
  ctx.textAlign = 'left';

  const content = events.filter(e => e.t <= elapsed && ['prompt','ai','code'].includes(e.type));
  const lH = 48, sY = tY + 78, sX = tX + 32;
  const maxL = Math.floor((tH - 90) / lH);
  content.slice(-maxL).forEach((ev, i) => {
    const y = sY + i * lH, age = elapsed - ev.t;
    ctx.globalAlpha = easeOut(Math.min(age / 350, 1));
    const fs = 20;
    if (ev.type === 'prompt') {
      ctx.font = `bold ${fs}px "SF Mono", monospace`; ctx.fillStyle = C.prompt;
      ctx.fillText('> ', sX, y);
      const pw = ctx.measureText('> ').width;
      ctx.font = `${fs}px "SF Mono", monospace`; ctx.fillStyle = C.text;
      const ch = Math.min(Math.floor(age / 28), ev.text.length);
      ctx.fillText(ev.text.substring(0, ch), sX + pw, y);
      if (ch < ev.text.length && Math.floor(elapsed/530)%2===0) {
        ctx.fillStyle = C.violet;
        ctx.fillRect(sX + pw + ctx.measureText(ev.text.substring(0,ch)).width + 2, y-15, 11, 22);
      }
    } else if (ev.type === 'ai') {
      ctx.font = `${fs}px "SF Mono", monospace`; ctx.fillStyle = C.ai;
      ctx.fillText(ev.text.substring(0, Math.min(Math.floor(age/22), ev.text.length)), sX+12, y);
    } else if (ev.type === 'code') {
      ctx.font = `${fs-1}px "SF Mono", monospace`; ctx.fillStyle = C.code;
      ctx.fillText(ev.text.substring(0, Math.min(Math.floor(age/18), ev.text.length)), sX+12, y);
    }
    ctx.globalAlpha = 1;
  });

  const pY = tY+tH-14, pX = tX+20, pW = tW-40;
  ctx.fillStyle = C.border; ctx.fillRect(pX, pY, pW, 2);
  const maxT = events[events.length-1].t;
  const g = ctx.createLinearGradient(pX,0,pX+pW,0);
  g.addColorStop(0,C.rust); g.addColorStop(1,C.gold);
  ctx.fillStyle = g; ctx.fillRect(pX, pY, Math.max((elapsed/maxT)*pW,2), 2);
  ctx.restore();
}

function drawImageReveal(elapsed) {
  const reveals = events.filter(e => e.type==='image-reveal' && e.t<=elapsed);
  const cur = reveals[reveals.length-1]; if (!cur) return;
  const age = elapsed - cur.t, img = images[cur.key];
  ctx.fillStyle = C.bg; ctx.fillRect(0,0,W,H);

  const iW=520, iH=620, iX=W-iW-60, iY=(H-iH)/2;
  ctx.globalAlpha = easeOut(Math.min(age/800,1));
  ctx.save(); drawRoundRect(iX,iY,iW,iH,8); ctx.clip();
  drawImageCover(img, iX, iY, iW, iH); ctx.restore();

  ctx.globalAlpha = Math.max(easeOut(Math.min((age-400)/600,1)),0);
  const lX=80, lY=H/2;
  ctx.font='500 12px -apple-system, sans-serif'; ctx.fillStyle=C.dim;
  ctx.fillText('REFRAMING RELATIONSHIPS', lX, lY-50);
  const parts = cur.label.split(' \u00b7 ');
  ctx.font='600 36px -apple-system, sans-serif'; ctx.fillStyle=C.text;
  ctx.fillText(parts[0], lX, lY-10);
  if (parts[1]) { ctx.font='300 22px -apple-system, sans-serif'; ctx.fillStyle=C.gold; ctx.fillText(parts[1], lX, lY+25); }
  ctx.globalAlpha = 1;
}

function drawImageGrid(elapsed) {
  const grids = events.filter(e => e.type==='image-grid' && e.t<=elapsed);
  const cur = grids[grids.length-1]; if (!cur) return;
  const age = elapsed - cur.t;
  ctx.fillStyle = C.bg; ctx.fillRect(0,0,W,H);

  const gap=16, tW=W-160, tH=H-120, cW=(tW-gap)/2, cH=(tH-gap)/2;
  cur.keys.forEach((key, i) => {
    const col=i%2, row=Math.floor(i/2);
    const x=80+col*(cW+gap), y=60+row*(cH+gap), delay=i*400, ca=age-delay;
    if (ca<0) return;
    const fade=easeOut(Math.min(ca/600,1)), scale=lerp(0.92,1,easeOut(Math.min(ca/800,1)));
    ctx.globalAlpha=fade;
    ctx.save();
    const cx=x+cW/2, cy=y+cH/2;
    ctx.translate(cx,cy); ctx.scale(scale,scale); ctx.translate(-cx,-cy);
    drawRoundRect(x,y,cW,cH,10); ctx.clip();
    drawImageCover(images[key], x, y, cW, cH);
    ctx.restore(); ctx.globalAlpha=1;
  });
}

function drawFrame(elapsed) {
  ctx.fillStyle = C.bg; ctx.fillRect(0,0,W,H);
  const mode = getActiveMode(elapsed);
  if (mode==='title-card') drawTitleCard(elapsed);
  else if (mode==='image-reveal') drawImageReveal(elapsed);
  else if (mode==='image-grid') drawImageGrid(elapsed);
  else drawTerminal(elapsed);

  ctx.globalAlpha=0.2; ctx.font='bold 13px -apple-system, sans-serif';
  ctx.fillStyle=C.dim; ctx.textAlign='right';
  ctx.fillText('codevibing', W-24, H-12);
  ctx.textAlign='left'; ctx.globalAlpha=1;

  const maxT=events[events.length-1].t;
  ctx.fillStyle='rgba(255,255,255,0.04)'; ctx.fillRect(0,H-3,W,3);
  const g=ctx.createLinearGradient(0,0,W,0);
  g.addColorStop(0,C.rust); g.addColorStop(1,C.violet);
  ctx.fillStyle=g; ctx.fillRect(0,H-3,Math.max((elapsed/maxT)*W,2),3);
}

function animate(ts) {
  if (!startTime) startTime = ts;
  currentElapsed = ts - startTime;
  drawFrame(currentElapsed);
  const maxT = events[events.length-1].t;
  if (currentElapsed < maxT + 2000) {
    animFrame = requestAnimationFrame(animate);
  } else {
    animRunning = false;
  }
}

function play() {
  startTime = null; zoom=1; zoomTarget=1; panY=0; panYTarget=0;
  currentElapsed = 0; animRunning = true;
  if (animFrame) cancelAnimationFrame(animFrame);
  animFrame = requestAnimationFrame(animate);
}

function jumpTo(t) {
  startTime = performance.now() - t;
  currentElapsed = t;
  if (!animRunning) {
    animRunning = true;
    animFrame = requestAnimationFrame(animate);
  }
}

// Click to advance to next event; if finished, replay
canvas.addEventListener('click', () => {
  const maxT = events[events.length - 1].t;
  if (!animRunning || currentElapsed >= maxT) {
    play(); return;
  }
  const next = events.find(e => e.t > currentElapsed + 200);
  if (next) {
    jumpTo(next.t);
  } else {
    jumpTo(maxT);
  }
});

// Autoplay once images are ready (or after 2s max)
function autoplay() {
  if (imagesLoaded >= Object.keys(imageSources).length) { play(); return; }
  if (imagesLoaded > 0) { play(); return; }
  setTimeout(play, 2000);
}
setTimeout(autoplay, 500);
</script>
</body>
</html>
